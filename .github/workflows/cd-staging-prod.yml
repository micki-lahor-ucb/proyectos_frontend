name: CD Frontend - Staging + Production

on:
  push:
    branches:
      - 'main'
    tags:
      - 'v*'
  workflow_dispatch:

jobs:
  build:
    name: Build Frontend Artifact
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run linter
        run: npm run lint:check

      - name: Run tests
        run: npm run test

      - name: Build frontend
        run: npm run build

      - name: Create RELEASE_ID
        run: |
          RELEASE_ID=$(date +%Y%m%d_%H%M%S)_${GITHUB_SHA:0:7}
          echo "$RELEASE_ID" > RELEASE_ID
          echo "RELEASE_ID=$RELEASE_ID" >> $GITHUB_ENV
          echo "Created RELEASE_ID: $RELEASE_ID"

      - name: Create release metadata
        run: |
          cat > dist/release-info.json <<EOF
          {
            "releaseId": "${{ env.RELEASE_ID }}",
            "commit": "${GITHUB_SHA}",
            "branch": "${GITHUB_REF_NAME}",
            "buildDate": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "version": "${GITHUB_REF_NAME}"
          }
          EOF
          cat dist/release-info.json

      - name: Upload frontend artifact
        uses: actions/upload-artifact@v4
        with:
          name: frontend-release-${{ github.ref_name }}
          path: |
            dist
            RELEASE_ID
          retention-days: 30

  deploy_staging:
    name: Deploy to Staging
    if: github.ref == 'refs/heads/main'
    runs-on: self-hosted
    needs: [build]
    environment:
      name: staging-frontend
      url: ${{ secrets.STAGING_FRONTEND_URL }}
    steps:
      - uses: actions/checkout@v4

      - name: Download frontend artifact
        uses: actions/download-artifact@v4
        with:
          name: frontend-release-${{ github.ref_name }}
          path: ./artifact

      - name: Read RELEASE_ID
        id: release
        shell: pwsh
        run: |
          $RELEASE_ID = Get-Content ./artifact/RELEASE_ID -Raw
          $RELEASE_ID = $RELEASE_ID.Trim()
          Add-Content -Path $env:GITHUB_OUTPUT -Value "RELEASE_ID=$RELEASE_ID"
          Write-Host "Deploying frontend release: $RELEASE_ID"

      - name: Deploy frontend to staging
        env:
          STAGING_HOST: ${{ secrets.STAGING_FRONTEND_HOST }}
          STAGING_USER: ${{ secrets.STAGING_FRONTEND_USER }}
          STAGING_SSH_KEY: ${{ secrets.STAGING_FRONTEND_SSH_KEY }}
          STAGING_PORT: ${{ secrets.STAGING_FRONTEND_PORT || '2223' }}
        shell: pwsh
        run: |
          $sshDir = "$env:USERPROFILE\.ssh"
          if (-not (Test-Path $sshDir)) { New-Item -ItemType Directory -Path $sshDir -Force | Out-Null }
          
          # Normalize host/user
          $remoteHost = ($env:STAGING_HOST ?? "").Trim()
          if ($remoteHost.Contains("@")) { $remoteHost = $remoteHost.Split("@")[-1] }
          if ($remoteHost.Contains(":")) { $remoteHost = $remoteHost.Split(":")[0] }
          if ([string]::IsNullOrWhiteSpace($remoteHost)) { throw "STAGING_FRONTEND_HOST is empty/invalid" }
          
          $remoteUser = ($env:STAGING_USER ?? "").Trim()
          if ($remoteUser.Contains("@")) { $remoteUser = $remoteUser.Split("@")[0] }
          if ([string]::IsNullOrWhiteSpace($remoteUser)) { throw "STAGING_FRONTEND_USER is empty/invalid" }
          
          $remote = "$remoteUser@$remoteHost"
          
          # Setup SSH known_hosts
          $knownHosts = Join-Path $sshDir "known_hosts_frontend_ci"
          if (Test-Path $knownHosts) { Remove-Item -Force $knownHosts }
          & ssh-keygen -R "[$remoteHost]:$env:STAGING_PORT" 2>$null | Out-Null
          & ssh-keygen -R $remoteHost 2>$null | Out-Null
          
          # Save SSH key
          $keyContent = $env:STAGING_SSH_KEY
          $keyContent = $keyContent -replace "`r`n", "`n" -replace "`r", "`n"
          $keyContent = $keyContent.TrimEnd("`n", "`r") + "`n"
          $utf8NoBom = New-Object System.Text.UTF8Encoding $false
          $bytes = $utf8NoBom.GetBytes($keyContent)
          [System.IO.File]::WriteAllBytes("$sshDir\deploy_key_frontend", $bytes)
          icacls "$sshDir\deploy_key_frontend" /inheritance:r /grant "$env:USERNAME`:F" | Out-Null
          
          $env:RELEASE = "${{ steps.release.outputs.RELEASE_ID }}"
          
          Write-Host "Creating frontend release directory..."
          $sshArgs = @(
            "-i", "$sshDir\deploy_key_frontend",
            "-p", $env:STAGING_PORT,
            "-o", "StrictHostKeyChecking=no",
            "-o", "UserKnownHostsFile=$knownHosts",
            "-o", "GlobalKnownHostsFile=$knownHosts",
            "-o", "BatchMode=yes",
            "-o", "IdentitiesOnly=yes",
            "-o", "PreferredAuthentications=publickey",
            "-o", "ConnectTimeout=10",
            "-o", "ServerAliveInterval=5",
            "-o", "ServerAliveCountMax=3",
            $remote,
            "mkdir -p /var/www/frontend/releases/$env:RELEASE"
          )
          & ssh @sshArgs
          if ($LASTEXITCODE -ne 0) { throw "Failed to create frontend release directory" }
          
          Write-Host "Packing frontend files..."
          $archive = "frontend-artifact-$env:RELEASE.tgz"
          if (Test-Path $archive) { Remove-Item -Force $archive }
          & tar -czf $archive -C ./artifact/dist .
          if ($LASTEXITCODE -ne 0) { throw "Failed to create tar.gz archive" }

          Write-Host "Copying frontend archive..."
          $scpArgs = @(
            "-i", "$sshDir\deploy_key_frontend",
            "-P", $env:STAGING_PORT,
            "-o", "StrictHostKeyChecking=no",
            "-o", "UserKnownHostsFile=$knownHosts",
            "-o", "GlobalKnownHostsFile=$knownHosts",
            "-o", "BatchMode=yes",
            "-o", "IdentitiesOnly=yes",
            "-o", "PreferredAuthentications=publickey",
            "-o", "ConnectTimeout=10",
            $archive,
            "${remote}:/var/www/frontend/releases/$env:RELEASE/"
          )
          & scp @scpArgs
          if ($LASTEXITCODE -ne 0) { throw "Failed to copy frontend archive" }

          Write-Host "Extracting and activating frontend release..."
          $deployScript = @"
          cd /var/www/frontend/releases/$env:RELEASE && \
          tar -xzf $archive && \
          rm -f $archive && \
          echo 'Extracted frontend release' && \
          ln -sfn /var/www/frontend/releases/$env:RELEASE /var/www/frontend/current && \
          echo 'Symlink updated to current release' && \
          readlink -f /var/www/frontend/current
          "@
          
          & ssh @sshArgs $deployScript
          if ($LASTEXITCODE -ne 0) { throw "Failed to extract/activate frontend release" }
          
          Write-Host "‚úÖ Frontend deployed to staging successfully"

      - name: Verify staging deployment
        run: |
          Start-Sleep -Seconds 5
          $url = "${{ secrets.STAGING_FRONTEND_URL }}"
          Write-Host "Checking frontend health at: $url"
          
          $maxRetries = 5
          $retryCount = 0
          $success = $false
          
          while (-not $success -and $retryCount -lt $maxRetries) {
            try {
              $response = Invoke-WebRequest -Uri $url -Method Get -TimeoutSec 10 -UseBasicParsing
              if ($response.StatusCode -eq 200) {
                Write-Host "‚úÖ Frontend staging health check passed"
                $success = $true
              }
            } catch {
              $retryCount++
              Write-Host "Attempt $retryCount failed. Retrying in 5 seconds..."
              Start-Sleep -Seconds 5
            }
          }
          
          if (-not $success) {
            throw "Frontend staging health check failed after $maxRetries attempts"
          }
        shell: pwsh

      - name: Verify release info endpoint
        run: |
          $url = "${{ secrets.STAGING_FRONTEND_URL }}/release-info.json"
          Write-Host "Checking release info at: $url"
          try {
            $response = Invoke-RestMethod -Uri $url -Method Get -TimeoutSec 10
            Write-Host "Release info: $($response | ConvertTo-Json)"
            Write-Host "‚úÖ Release ID: $($response.releaseId)"
          } catch {
            Write-Host "‚ö†Ô∏è Release info endpoint not available (non-critical)"
          }
        shell: pwsh

  deploy_production:
    name: Deploy to Production
    if: startsWith(github.ref, 'refs/tags/v') || github.event_name == 'workflow_dispatch'
    runs-on: self-hosted
    needs: [deploy_staging]
    environment:
      name: production-frontend
      url: ${{ secrets.PROD_FRONTEND_URL }}
    steps:
      - uses: actions/checkout@v4

      - name: Download frontend artifact
        uses: actions/download-artifact@v4
        with:
          name: frontend-release-${{ github.ref_name }}
          path: ./artifact

      - name: Read RELEASE_ID
        id: release
        shell: pwsh
        run: |
          $RELEASE_ID = Get-Content ./artifact/RELEASE_ID -Raw
          $RELEASE_ID = $RELEASE_ID.Trim()
          Add-Content -Path $env:GITHUB_OUTPUT -Value "RELEASE_ID=$RELEASE_ID"
          Write-Host "Deploying frontend to PRODUCTION: $RELEASE_ID"

      - name: Deploy frontend to production
        env:
          PROD_HOST: ${{ secrets.PROD_FRONTEND_HOST }}
          PROD_USER: ${{ secrets.PROD_FRONTEND_USER }}
          PROD_SSH_KEY: ${{ secrets.PROD_FRONTEND_SSH_KEY }}
          PROD_PORT: ${{ secrets.PROD_FRONTEND_PORT || '2224' }}
        shell: pwsh
        run: |
          $sshDir = "$env:USERPROFILE\.ssh"
          if (-not (Test-Path $sshDir)) { New-Item -ItemType Directory -Path $sshDir -Force | Out-Null }
          
          # Normalize host/user
          $remoteHost = ($env:PROD_HOST ?? "").Trim()
          if ($remoteHost.Contains("@")) { $remoteHost = $remoteHost.Split("@")[-1] }
          if ($remoteHost.Contains(":")) { $remoteHost = $remoteHost.Split(":")[0] }
          if ([string]::IsNullOrWhiteSpace($remoteHost)) { throw "PROD_FRONTEND_HOST is empty/invalid" }
          
          $remoteUser = ($env:PROD_USER ?? "").Trim()
          if ($remoteUser.Contains("@")) { $remoteUser = $remoteUser.Split("@")[0] }
          if ([string]::IsNullOrWhiteSpace($remoteUser)) { throw "PROD_FRONTEND_USER is empty/invalid" }
          
          $remote = "$remoteUser@$remoteHost"
          
          # Setup SSH known_hosts
          $knownHosts = Join-Path $sshDir "known_hosts_frontend_prod"
          if (Test-Path $knownHosts) { Remove-Item -Force $knownHosts }
          & ssh-keygen -R "[$remoteHost]:$env:PROD_PORT" 2>$null | Out-Null
          & ssh-keygen -R $remoteHost 2>$null | Out-Null
          
          # Save SSH key
          $keyContent = $env:PROD_SSH_KEY
          $keyContent = $keyContent -replace "`r`n", "`n" -replace "`r", "`n"
          $keyContent = $keyContent.TrimEnd("`n", "`r") + "`n"
          $utf8NoBom = New-Object System.Text.UTF8Encoding $false
          $bytes = $utf8NoBom.GetBytes($keyContent)
          [System.IO.File]::WriteAllBytes("$sshDir\deploy_key_frontend_prod", $bytes)
          icacls "$sshDir\deploy_key_frontend_prod" /inheritance:r /grant "$env:USERNAME`:F" | Out-Null
          
          $env:RELEASE = "${{ steps.release.outputs.RELEASE_ID }}"
          
          Write-Host "üöÄ Creating PRODUCTION frontend release directory..."
          $sshArgs = @(
            "-i", "$sshDir\deploy_key_frontend_prod",
            "-p", $env:PROD_PORT,
            "-o", "StrictHostKeyChecking=no",
            "-o", "UserKnownHostsFile=$knownHosts",
            "-o", "GlobalKnownHostsFile=$knownHosts",
            "-o", "BatchMode=yes",
            "-o", "IdentitiesOnly=yes",
            "-o", "PreferredAuthentications=publickey",
            "-o", "ConnectTimeout=10",
            "-o", "ServerAliveInterval=5",
            "-o", "ServerAliveCountMax=3",
            $remote,
            "mkdir -p /var/www/frontend/releases/$env:RELEASE"
          )
          & ssh @sshArgs
          if ($LASTEXITCODE -ne 0) { throw "Failed to create PRODUCTION frontend release directory" }
          
          Write-Host "üì¶ Packing frontend files..."
          $archive = "frontend-artifact-$env:RELEASE.tgz"
          if (Test-Path $archive) { Remove-Item -Force $archive }
          & tar -czf $archive -C ./artifact/dist .
          if ($LASTEXITCODE -ne 0) { throw "Failed to create tar.gz archive" }

          Write-Host "üì§ Copying frontend to PRODUCTION..."
          $scpArgs = @(
            "-i", "$sshDir\deploy_key_frontend_prod",
            "-P", $env:PROD_PORT,
            "-o", "StrictHostKeyChecking=no",
            "-o", "UserKnownHostsFile=$knownHosts",
            "-o", "GlobalKnownHostsFile=$knownHosts",
            "-o", "BatchMode=yes",
            "-o", "IdentitiesOnly=yes",
            "-o", "PreferredAuthentications=publickey",
            "-o", "ConnectTimeout=10",
            $archive,
            "${remote}:/var/www/frontend/releases/$env:RELEASE/"
          )
          & scp @scpArgs
          if ($LASTEXITCODE -ne 0) { throw "Failed to copy frontend to PRODUCTION" }

          Write-Host "üîÑ Activating PRODUCTION frontend release (atomic symlink)..."
          $deployScript = @"
          cd /var/www/frontend/releases/$env:RELEASE && \
          tar -xzf $archive && \
          rm -f $archive && \
          echo '‚úÖ Extracted PRODUCTION frontend release' && \
          ln -sfn /var/www/frontend/releases/$env:RELEASE /var/www/frontend/current && \
          echo '‚úÖ Atomic symlink updated to current release' && \
          readlink -f /var/www/frontend/current
          "@
          
          & ssh @sshArgs $deployScript
          if ($LASTEXITCODE -ne 0) { throw "Failed to activate PRODUCTION frontend release" }
          
          Write-Host "‚úÖ Frontend deployed to PRODUCTION successfully"

      - name: Verify production deployment
        run: |
          Start-Sleep -Seconds 5
          $url = "${{ secrets.PROD_FRONTEND_URL }}"
          Write-Host "üîç Checking PRODUCTION frontend health at: $url"
          
          $maxRetries = 5
          $retryCount = 0
          $success = $false
          
          while (-not $success -and $retryCount -lt $maxRetries) {
            try {
              $response = Invoke-WebRequest -Uri $url -Method Get -TimeoutSec 10 -UseBasicParsing
              if ($response.StatusCode -eq 200) {
                Write-Host "‚úÖ PRODUCTION frontend health check passed"
                $success = $true
              }
            } catch {
              $retryCount++
              Write-Host "Attempt $retryCount failed. Retrying in 5 seconds..."
              Start-Sleep -Seconds 5
            }
          }
          
          if (-not $success) {
            throw "PRODUCTION frontend health check failed after $maxRetries attempts"
          }
        shell: pwsh

      - name: Verify production release info
        run: |
          $url = "${{ secrets.PROD_FRONTEND_URL }}/release-info.json"
          Write-Host "üîç Checking PRODUCTION release info at: $url"
          try {
            $response = Invoke-RestMethod -Uri $url -Method Get -TimeoutSec 10
            Write-Host "üìä Release info: $($response | ConvertTo-Json)"
            Write-Host "‚úÖ Release ID: $($response.releaseId)"
            Write-Host "‚úÖ Commit: $($response.commit)"
            Write-Host "‚úÖ Version: $($response.version)"
          } catch {
            Write-Host "‚ö†Ô∏è Release info endpoint not available (non-critical)"
          }
        shell: pwsh

  rollback_staging:
    name: Rollback Staging
    if: failure() && needs.deploy_staging.result == 'failure'
    runs-on: self-hosted
    needs: [deploy_staging]
    environment:
      name: staging-frontend
    steps:
      - name: Rollback to previous release
        env:
          STAGING_HOST: ${{ secrets.STAGING_FRONTEND_HOST }}
          STAGING_USER: ${{ secrets.STAGING_FRONTEND_USER }}
          STAGING_SSH_KEY: ${{ secrets.STAGING_FRONTEND_SSH_KEY }}
          STAGING_PORT: ${{ secrets.STAGING_FRONTEND_PORT || '2223' }}
        shell: pwsh
        run: |
          Write-Host "üîÑ Initiating ROLLBACK for staging frontend..."
          
          $sshDir = "$env:USERPROFILE\.ssh"
          
          $remoteHost = ($env:STAGING_HOST ?? "").Trim()
          if ($remoteHost.Contains("@")) { $remoteHost = $remoteHost.Split("@")[-1] }
          if ($remoteHost.Contains(":")) { $remoteHost = $remoteHost.Split(":")[0] }
          
          $remoteUser = ($env:STAGING_USER ?? "").Trim()
          if ($remoteUser.Contains("@")) { $remoteUser = $remoteUser.Split("@")[0] }
          
          $remote = "$remoteUser@$remoteHost"
          $knownHosts = Join-Path $sshDir "known_hosts_frontend_ci"
          
          $keyContent = $env:STAGING_SSH_KEY
          $keyContent = $keyContent -replace "`r`n", "`n" -replace "`r", "`n"
          $keyContent = $keyContent.TrimEnd("`n", "`r") + "`n"
          $utf8NoBom = New-Object System.Text.UTF8Encoding $false
          $bytes = $utf8NoBom.GetBytes($keyContent)
          [System.IO.File]::WriteAllBytes("$sshDir\deploy_key_frontend", $bytes)
          icacls "$sshDir\deploy_key_frontend" /inheritance:r /grant "$env:USERNAME`:F" | Out-Null
          
          $sshArgs = @(
            "-i", "$sshDir\deploy_key_frontend",
            "-p", $env:STAGING_PORT,
            "-o", "StrictHostKeyChecking=no",
            "-o", "UserKnownHostsFile=$knownHosts",
            "-o", "BatchMode=yes",
            "-o", "IdentitiesOnly=yes",
            $remote
          )
          
          $rollbackScript = @"
          PREV=`$(ls -1dt /var/www/frontend/releases/*/ 2>/dev/null | sed -n '2p' | tr -d '/') && \
          if [ -n "`$PREV" ]; then \
            echo "Rolling back to: `$PREV"; \
            ln -sfn /var/www/frontend/releases/`$PREV /var/www/frontend/current && \
            echo "‚úÖ Rollback successful" && \
            readlink -f /var/www/frontend/current; \
          else \
            echo "‚ö†Ô∏è No previous release found"; \
            exit 1; \
          fi
          "@
          
          & ssh @sshArgs $rollbackScript
          if ($LASTEXITCODE -eq 0) {
            Write-Host "‚úÖ Staging frontend rolled back successfully"
          } else {
            Write-Host "‚ùå Rollback failed - no previous release available"
          }

  rollback_production:
    name: Rollback Production
    if: failure() && needs.deploy_production.result == 'failure'
    runs-on: self-hosted
    needs: [deploy_production]
    environment:
      name: production-frontend
    steps:
      - name: Rollback to previous release
        env:
          PROD_HOST: ${{ secrets.PROD_FRONTEND_HOST }}
          PROD_USER: ${{ secrets.PROD_FRONTEND_USER }}
          PROD_SSH_KEY: ${{ secrets.PROD_FRONTEND_SSH_KEY }}
          PROD_PORT: ${{ secrets.PROD_FRONTEND_PORT || '2224' }}
        shell: pwsh
        run: |
          Write-Host "üîÑ Initiating ROLLBACK for PRODUCTION frontend..."
          
          $sshDir = "$env:USERPROFILE\.ssh"
          
          $remoteHost = ($env:PROD_HOST ?? "").Trim()
          if ($remoteHost.Contains("@")) { $remoteHost = $remoteHost.Split("@")[-1] }
          if ($remoteHost.Contains(":")) { $remoteHost = $remoteHost.Split(":")[0] }
          
          $remoteUser = ($env:PROD_USER ?? "").Trim()
          if ($remoteUser.Contains("@")) { $remoteUser = $remoteUser.Split("@")[0] }
          
          $remote = "$remoteUser@$remoteHost"
          $knownHosts = Join-Path $sshDir "known_hosts_frontend_prod"
          
          $keyContent = $env:PROD_SSH_KEY
          $keyContent = $keyContent -replace "`r`n", "`n" -replace "`r", "`n"
          $keyContent = $keyContent.TrimEnd("`n", "`r") + "`n"
          $utf8NoBom = New-Object System.Text.UTF8Encoding $false
          $bytes = $utf8NoBom.GetBytes($keyContent)
          [System.IO.File]::WriteAllBytes("$sshDir\deploy_key_frontend_prod", $bytes)
          icacls "$sshDir\deploy_key_frontend_prod" /inheritance:r /grant "$env:USERNAME`:F" | Out-Null
          
          $sshArgs = @(
            "-i", "$sshDir\deploy_key_frontend_prod",
            "-p", $env:PROD_PORT,
            "-o", "StrictHostKeyChecking=no",
            "-o", "UserKnownHostsFile=$knownHosts",
            "-o", "BatchMode=yes",
            "-o", "IdentitiesOnly=yes",
            $remote
          )
          
          $rollbackScript = @"
          PREV=`$(ls -1dt /var/www/frontend/releases/*/ 2>/dev/null | sed -n '2p' | tr -d '/') && \
          if [ -n "`$PREV" ]; then \
            echo "üîÑ Rolling back PRODUCTION to: `$PREV"; \
            ln -sfn /var/www/frontend/releases/`$PREV /var/www/frontend/current && \
            echo "‚úÖ PRODUCTION Rollback successful" && \
            readlink -f /var/www/frontend/current; \
          else \
            echo "‚ö†Ô∏è No previous PRODUCTION release found"; \
            exit 1; \
          fi
          "@
          
          & ssh @sshArgs $rollbackScript
          if ($LASTEXITCODE -eq 0) {
            Write-Host "‚úÖ PRODUCTION frontend rolled back successfully"
          } else {
            Write-Host "‚ùå PRODUCTION Rollback failed - no previous release available"
          }
